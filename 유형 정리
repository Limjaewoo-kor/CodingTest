1)정렬 - 
1. 선택정렬 - 처리되지 않은 데이터 중에서 가장 작은 데이터를 선택하여 맨앞에 있는 데이터와 바꾸는것 을 반복한다.

동작원리 - 전체 데이터중 제일 작은 데이터를 맨앞의 데이터와 바꾸어 정렬해준다.
             - 정렬되지않은 남은 데이터중 제일 작은 데이터를 두번째 데이터와 바꾸어준다.
             - 해당 과정을 반복한다.
[N2]

//  선택정렬
    public static void main(String[] args) {


        int n = 10;
        int[] arr = {7, 5, 9, 0, 3, 1, 6, 2, 4, 8};

        for (int i = 0; i < n; i++) {
            int idx = i;
            for (int j = i + 1; j < n; j++) {
                if (arr[idx] > arr[j]) {
                    idx = j;
                }
            }
            int tmp = arr[i];
            arr[i] = arr[idx];
            arr[idx] = tmp;
        }
        for (int i = 0; i < n; i++) {
            System.out.println(arr[i] + " ");
        }
    }


2. 삽입정렬
- 처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입한다.
- 선택정렬보다 효율적이다.

동작원리 - 첫번째 데이터는 정렬이 되어있다고 판단하고, 두번째 데이터가 첫번째 데이터의 왼쪽으로 들어갈지 오른쪽으로 들어갈지 판단한다.
 - 그다음 데이터도 앞의 데이터들과 하나씩 비교하여 왼쪽으로 갈지 오른쪽으로 갈지 판단한다.

[N2]
    public static void main(String[] args) {

        int n = 10;
        int[] arr = {7, 5, 9, 0, 3, 1, 6, 2, 4, 8};

        for (int i = 1; i < n; i++) {
            for (int j = i; j > 0; j--) {
               if (arr[j] < arr[j-1]) {
                   int tmp = arr[j];
                   arr[j] = arr[j-1];
                   arr[j-1] = tmp;
               }
               else break;
            }
        }

        for (int i = 0; i < n; i++) {
            System.out.println(arr[i] + " ");
        }
    }

3. 퀵 정렬
- 기준 데이터를 설정하고 그 기준보다 큰데이터와 작은데이터의 위치를 바꾸는 방법이다.
- 가장 많이 사용되는 정렬알고리즘이며, 병합정렬과 더불어 정렬라이브러리의 근간이 된다.
- 가장 기본적인 퀵정렬은 첫번째 데이터를 피벗으로 정한다.

동작원리 
- 첫번째 데이터를 피벗으로 정한뒤 왼쪽에서부터 피벗보다 큰 데이터를 선택하고,  
   오른쪽에서부터 피벗보다 작은데이터를 선택하여 두 데이터의 위치를 서로 변경한다.
- 위의 과정을 두개의 포인터가 교차되기전까지 위의 과정을 반복하며, 위치가 엇갈릴경우 피벗과 '작은데이터'의 위치를 변경한다.
평균 - [NlogN] 한쪽으로 원소가 편향된경우에는 최악의 경우 [N2]이 될수도있다.


4. 계수 정렬
- 특정한 조건이 부합할때만 사용할수 있으나, 매우빠른 정렬알고리즘 중 하나이다. 
- 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을때만 사용가능하다.
- 데이터의 개수 N , 데이터의 최대값 K 일때 최악의 경우에도 수행시간 [O(N+K)]를 보장한다.

동작원리 
- 가장 작은 데이터부터 가장 큰 데이터까지의 범위가 모두 담길 수 있도록 리스트를 생성한다.
- 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가시킨다.
- 각 원소의 카운트를 구한뒤에 리스트의 첫번째 데이터부터 하나씩 그 값만큼 반복하여 인덱스를 출력한다


2) 이진탐색 (binarySearch)
정렬되어 있는 리스트에서 탐색범위를 절반씩 줄여가며 데이터를 탐색하는 방법
시작점,끝점,중간점을 이용하여 탐색범위를 설정한다

동작원리 
- 정렬된 리스트에 시작점[lt] , 끝점[rt]를 지정하고 rt의 절반값[소수점이라면 버림수행]에 mid를 설정하고
  찾으려는 값보다 mid가 크면 끝점을 mid-1로 줄이고 mid가 작으면 시작점을 mid+1로 늘린다, 해당 작업을 반복한다.
[logN]

3) 파라메트릭 서치 (Parametric Search)
최적화문제를 결정문제로 바꾸어서 해결하는 기법이다.[예/아니오]
파라메트릭 서치 문제는 이진탐색을 이용하여 해결할 수 있다. [참고 떡볶이 떡 문제]

4) 다이나믹 프로그래밍 [DP]
- 탑다운과 바텀업 방식으로 구성된다.
- 메모리를 적절히 사용하여 수행시간 효율성을 비약적으로 향상시키는 방법이다.
- 이미 계산된 결과[작은 문제]는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록한다.
	[예를들어 5팩토리얼계산후 6팩토리얼을 계산한다면 전부 재귀를 돌리는게 아닌 메모리에서 5팩토리얼 값을 가져와서 추가로 한번만 더 연산해준다.]
동적계획법이라고도 불린다.

조건- 
1. 최적부분구조(Optimal Substructure) 큰 문제를 작은 문제로 나눌수 있어야한다.
2. 중복되는 부분 문제 (Overlapping Subproblem) 동일한 작은 문제를 반복적으로 해결한다.

4-1) 하향식[탑다운 방식](재귀함수이용)
- 메모이제이션(Memoization)  한번 계산한 결과를 메모리 공간에 저장하는 기법이다, 값을 기록해놓는다는 점에서 캐싱이라고도 한다.

4-2) 전형적인 형태는 상향식[바텀업 방식]이다.
- 결과저장용 리스트는 보통 DP테이블이라고 부른다.

다이나믹 프로그래밍과 분할 정복의 차이
- 분할정복의 예시로는 퀵정렬을 들 수 있는데, 퀵정렬의 경우 피벗이 정렬된 후에는 그 피벗을 다시 처리한다던가 호출하지않는다.

다이나믹프로그래밍 문제에 접근하려면, 먼저 그리디,구현,완전탐색등으로 문제가 해결이 가능한지 판단하고 불가하다면, 재귀함수등의 방법으로 프로그램을 작성한뒤에 개선하는 방법이 있다.
 
- 가장 긴 증가하는 부분 수열 (Longest Increasing Subsequence, LIS)는 전형적인 다이나믹 프로그래밍 문제의 아이디어이다.

5) 최단 경로 알고리즘
- 말그대로 최단 경로를 찾는 알고리즘이며, 노드와 간선으로 표현된다
- 가장 대표적인 최단경로 알고리즘은 다익스트라 알고리즘이며 특정한 노드에서 다른 모든 노드로 가는 최단경로를 계산한다.
-- 조건으로 음의간선이 없어야하며, 매 상황에서 가장 비용이 적은 노드를 선택해 임의의 과정을 반복한다는 점에서 그리디 알고리즘이라고 하며 DP적용된 문제이기도한다.
