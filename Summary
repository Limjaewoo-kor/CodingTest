에라토스테네스의 체 - 소수구하기 // 해당 수를 제외하고 배수를 모두 지운다

아나그램 - 같은 단어로 배열만 바꾼것  [해시 + 슬라이딩윈도우 ]

팰린드롬 - 앞으로해도 뒤로해도 같은 단어 [ 문자열(StringBuilder.reverse) + replaceAll ]

최대매출 - [ SlidingWindow ] 창문 형태로 밀어내기 창문의 첫번째 값을 빼고 마지막값을 더한다 반복 

배열 합치기, 공통원소 구하기 - [ twopointer ]  p1,p2 혹은 lt,rt로 두가지 포인트를 잡아서 진행한다. 

후위식연산 - 스택으로 넣어서 진행 먼저들어간 숫자 lt, 나중에 들어간숫자 rt로 연산

피보나치수열 - [ Array ] (i-1) + i 값은 i+2 값과 일치한다.

K번째큰수 - 중복제거가 필요할땐 HashMap이 아닌 TreeSet을 사용한다.

스택문제 - 괄호 연산 등  리포

큐문제 - 라우터문제  피포

선택정렬 - 첫번째수를 반복문으로 다음 수들과 비교하면서 제일 작은수를 첫번째 인덱스에 넣음. -> 한바퀴 돌았을때 제일 작은수가 맨앞 인덱스로 이동

버블정렬 - 첫번째수와 바로 다음수를 비교하여 큰수를 뒤로 밀음 -> 한바퀴 돌았을때 제일 큰수가 맨뒤 인덱스로 이동

삽입정렬 - i가 0이아닌 1부터 시작하며 i번째수를 tmp에 넣고 i보다 작은 인덱스들에 있는 수와 비교하여 작으면 i번째수를 i-1번째로 이동하고 tmp를 i번째에 넣음

이분탐색 - 반복문이 시간초과할때 대체할 수 있으며, 0부터 N까지 반복하는게 아니며, lt,rt,mid를 설정하여 mid값과 비교하여 크거나 작음에따라 lt,rt의 범위를 이동시켜 절반씩 줄여나간다.

재귀함수 - 본인을 호출하는 함수이며, 메서드 첫부분에 if문을 만들어서 끝나는 조건을 넣고 else일때 재귀 로직을 타게한다.

트리 - 이진트리 유형.

그래프(DFS , BFS) - 깊이 탐색 / 넓이 탐색이며, 깊이탐색은 전위,중위,후위탐색을 기억하고 넓이탐색은 레벨을 기억할것.  ex)최단거리
==========================================================================================================================================================================================
그리디알고리즘 - 단순히 가장 좋은것을 고름 / 최적의 해는 보장하지 못하는 경우가 많기때문에, 얻은 해가 최적의 해가 되는 상황에서 이를 추론할 수 있어야한다.
                              거스름돈 / 1이 될때 등의 문제가 있음. 
                              
구현 - 요구사항대로 풀이를 생각하여 소스코드로 옮기는 문제를 뜻한다. 대체적으로 알고리즘은 간단한테 코드가 지나치게 길다거나, 문자열 스플릿이나 소수점자리 관련 조건들이 있다.
       적절한 라이브러리를 찾아야한다.
       시뮬레이션 및 완전탐색 문제가 있으며, 여기서는 2차원 배열에 방향벡터가 자주 활용된다.

스택 - 스택은 마지막에 넣은값이 먼저 나온다.

큐 - 큐는 처음에 넣은값이 먼저 나온다.

재귀함수(Recursive Function) - DFS 구현시에 필요하며, 자기 자신 호출하는 함수를 뜻한다, 사용시에는 if절에 종료 조건을 작성하고 매개변수를 바꿔가며 본인을 계속하여 호출한다.
                              팩토리얼 / 유클리드 호제법(최대공약수) / 모든 재귀함수는 반복문으로 구현가능하다. - 상황에따라 유리하거나 불리할 수 있다.
                              
그래프(DFS) - 깊이 우선탐색이라고 부르며, 스택 혹은 재귀함수를 이용한다.
              1. 시작 노드를 스택에 넣고 방문처리한다.
              2. 스택의 최상단에 방문하지 않은 인접한 노드가 있으면 그 노드를 스택에 넣고 방문 처리한다, 없으면 스택에서 최상단 노드를 꺼낸다.
              3. 더이상 수행할 수 없을때까지 반복한다.
              
그래프(BFS) - 너비 우선탐색이라고 부르며, 가까운 노드부터 우선적으로 탐색하는 알고리즘이다, 큐를 이용한다.
              1. 시작 노드를 큐에 넣고 방문처리한다.
              2. 큐에서 노드를 꺼낸뒤 해당 노드의 인접노드중에서 방문하지 않은 노드를 모두 큐에 넣고 방문처리한다.
              3. 더이상 수행할 수 없을때까지 반복한다.

정렬 - 
1. 선택정렬 - 전체 데이터중 제일 작은 데이터를 맨앞의 데이터와 바꾸어 정렬해준다.
	  - 정렬되지않은 남은 데이터중 제일 작은 데이터를 두번째 데이터와 바꾸어준다.
	  - 해당 과정을 반복한다.
//  선택정렬
    public static void main(String[] args) {


        int n = 10;
        int[] arr = {7, 5, 9, 0, 3, 1, 6, 2, 4, 8};

        for (int i = 0; i < n; i++) {
            int idx = i;
            for (int j = i + 1; j < n; j++) {
                if (arr[idx] > arr[j]) {
                    idx = j;
                }
            }
            int tmp = arr[i];
            arr[i] = arr[idx];
            arr[idx] = tmp;
        }
        for (int i = 0; i < n; i++) {
            System.out.println(arr[i] + " ");
        }
    }


다이나믹프로그래밍[DP]

완전탐색[브루트포스] - 
